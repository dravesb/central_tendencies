{
  "hash": "ba0238a7988e116206d1379688caba41",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Paper Notes - GroupLens: An Open Architecture for Collaborative Filtering of Netnews\"\ndescription: \"Paper notes on original GroupLens paper introducing Collaborative Filtering for new article recommendation\"\nauthor:\n  - name: Benjamin Draves\ndate: 2024-11-17\ncategories: [machine-learning, recommendation-systems, collaborative-filters, paper-notes] # self-defined categories\ndraft: true \nformat:\n  html:\n    code-fold: true\njupyter: python3\n---\n\n\n# Paper Overview\n\nThe [*GroupLens: An Open Architecture for Collaborative Filtering of Netnews*](http://dx.doi.org/10.1145/192844.192905) paper was one of the first papers to introduce collaborative filtering for recommendation applications in 1994. \nThe paper focuses on not just the recommendation problem but also how those recommendations are integrated into the Usenet netnews network, displayed to users, and implications for serving personalized news to users. \n\n\n# Introduction & Problem\n\nUsenet's netnews platform was an original social news aggregation network. \nNetnews created and shared bulletin boards where users could post news related to certain topics (see @fig-netnews). \nThis mimics many modern day social media platforms (most notably Reddit).\nWhile users could see and read news posted from other users, users noted that the \"signal to noise\" ratio was too low and had to rely on moderators and basic software (called news agents) to screen, remove, or boost certain news content. \n\n![*Figure*: Netnews design and architecture. Figure 1 in Resnick et al. 1994](netnews_architecture.jpg)\n\n\nWhile some of this was successful, most of these approaches were primitive and would not scale to many users and articles. \nGroupLens attempted to create a system (a news client) that would take into account user ratings to *collaboratively* filter our irrelevant news articles bases on the uses ratings of previous articles.  \nThe stated goals of GroupLens was to \n\n1. Openess - other devs could change the rating system to address their own objectives. \n2. Ease of use - users could supply ratings to news articles was non-invasive \n3. Compatibility - the news client was accessible to all Netnews users\n4. Scalability - the rating mechanism scaled to many users and many articles \n5. Privacy - ensure users ratings privacy were preserved\n\n# Methods \nThe paper spend a good deal of time discussing the architecture of *how* article ratings will get passed from server to server to influence filtering of articles for new users (see Figure 2 for instance).\nThe authors also spend time discussing the tradeoffs from building GroupLens on explicit ratings (e.g. user scores on each article from 1-5) versus implicit ratings (e.g. time spend reading each article).\nIn modern applications, most recommendation systems focus on incorporating both explicit and implicit feedback but tend to focus on the later due to higher throughput and reliability of implicit feedback mechanisms (e.g. [TikTok's dwell time](https://support.tiktok.com/en/using-tiktok/exploring-videos/how-tiktok-recommends-content)).\n\nThe authors ultimately decide to focus on explicit article ratings and treated the recommendation problem as a matrix completion problem. \n\n## Collaborative Filtering\nFor each user $u\\in\\mathcal{U}$ and item $v\\in\\mathcal{V}$ we assign the rating $u$ assigns to $v$ as $R_{uv}$. \nSupposing $\\mid\\mathcal{U}\\mid = n$ and $\\mid\\mathcal{V}\\mid = m$ the ratings matrix $\\mathbf{R}\\in\\mathbb{R}^{n\\times m}$ with \n\n$$\n\\mathbf{R} = \\begin{bmatrix}\nR_{11} & \\dots & R_{1m}\\\\\nR_{21} & \\dots & R_{2m}\\\\\n\\vdots & \\ddots & \\vdots\\\\\nR_{n1} & \\dots & R_{nm}\n\\end{bmatrix}\n$$\n\nNow, several entries in $\\mathbf{R}$ will be missing as not every (user, item) pair will be rated.\n\nThe authors impute this missing scores based on the hueristic that \"people who agreed in the past are likely to agree again.\"\nTo impute the missing rating $R_{uv}$ they follow: \n\n1. Understand how similar user $u$ is to all other users. \n2. Score the item $v$ based on previous ratings of other users on $v$ *taking into account how similar the user is to $u$*. \n\nThis manifests in the scoring equation \n$$ \n\\hat{R}_{uv} = \\bar{R_u} + \\frac{\\sum_{i\\neq u} \\text{sim}(u, i)(R_{iv} - \\bar{R}_i)}{\\sum_{i\\neq u} |\\text{sim}(u, i)|}\n$$\n\nHere, we first residualize all ratings relative to the user's average rating. \nThis removes any user-level bias or different interpretations of the rating scale. \nFrom here, we simply take a weighted sum of the ratings on item $v$ for each user, weighted by the similarity between the user providing that rating $i$ and user $u$. \nThe authors propose to model user-to-user similarity using simple correlation scores: \n\n$$ \n\\text{sim}(u, s) = \\frac{\\sum_{j=1}^m(R_{uj} - \\bar{R}_{u})(R_{sj} - \\bar{R}_{s})}{\\sqrt{\\sum_{j=1}^m(R_{uj} - \\bar{R}_{u})^2}\\sqrt{\\sum_{j=1}^m(R_{sj} - \\bar{R}_{s})^2}} \\in [-1, 1]\n$$\n\nIn both of these equations, if $R_{uv}$ is unobserved, then that term in the summand is removed. \nTherefore, if two users $(u, s)$ do not score any of the same items, their similarity is set to zero and user $s$ ratings do not impact the rating estimates for user $u$. \n\n## Collaborative Filtering - Extensions\nThe authors point out a number of limitations\n\n# Application\n\n# Conclusion and other Notes\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}